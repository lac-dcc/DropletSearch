avg 128 168 83 83 1 2 VALID
Time cost of this operator: 0.0006501600
Lowered TIR:
@main = primfn(data_1: handle, tensor_1: handle) -> ()
  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
  buffers = {tensor: Buffer(tensor_2: Pointer(float32), float32, [128, 168, 42, 42], []),
             data: Buffer(data_2: Pointer(float32), float32, [128, 168, 83, 83], [])}
  buffer_map = {data_1: data, tensor_1: tensor} {
  attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 148176;
  allocate(tensor_3: Pointer(local float32), float32, [1]), storage_scope = local;
  attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 256 {
    tensor_3[0] = 0f32
    tensor_3[0] = ((float32*)tensor_3[0] + (float32*)data_2[(((floordiv(((blockIdx.x*256) + threadIdx.x), 1764)*6889) + (floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 1764), 42)*166)) + (floormod(((blockIdx.x*256) + threadIdx.x), 42)*2))])
    tensor_2[((blockIdx.x*256) + threadIdx.x)] = (float32*)tensor_3[0]
  }
}


; ModuleID = 'TVMAMDGPUModule'
source_filename = "TVMAMDGPUModule"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa-hcc"

; Function Attrs: nofree nounwind
define dllexport amdgpu_kernel void @default_function_kernel0(float addrspace(1)* noalias nocapture readonly %0, float addrspace(1)* noalias nocapture %1) local_unnamed_addr #0 {
entry:
  %2 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %3 = tail call i32 @llvm.amdgcn.workitem.id.x()
  %4 = shl nsw i32 %2, 8
  %5 = add nsw i32 %4, %3
  %6 = srem i32 %5, 42
  %7 = shl nsw i32 %6, 1
  %8 = sdiv i32 %5, 1764
  %9 = mul i32 %8, 1764
  %.decomposed = sub i32 %5, %9
  %10 = sdiv i32 %.decomposed, 42
  %11 = mul nsw i32 %10, 166
  %12 = mul nsw i32 %8, 6889
  %13 = add i32 %7, %12
  %14 = add i32 %13, %11
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds float, float addrspace(1)* %0, i64 %15
  %17 = load float, float addrspace(1)* %16, align 4, !tbaa !4
  %18 = fadd float %17, 0.000000e+00
  %19 = sext i32 %5 to i64
  %20 = getelementptr inbounds float, float addrspace(1)* %1, i64 %19
  store float %18, float addrspace(1)* %20, align 4, !tbaa !8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workgroup.id.x() #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nofree nounwind "amdgpu-flat-work-group-size"="1,1024" "no-nans-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 12.0.0 (/src/external/llvm-project/clang 1100ebe275a9dcc79a9abbda902b6f10738f2f5d)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"0x2c537b0", !7, i64 0}
!7 = !{!"tvm-tbaa"}
!8 = !{!9, !9, i64 0}
!9 = !{!"float", !10, i64 0}
!10 = !{!"0x2a12d10", !7, i64 0}

avg 128 672 21 21 3 2 SAME
Time cost of this operator: 0.0004084198
Lowered TIR:
@main = primfn(data_1: handle, tensor_1: handle) -> ()
  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
  buffers = {tensor: Buffer(tensor_2: Pointer(float32), float32, [128, 672, 11, 11], []),
             data: Buffer(data_2: Pointer(float32), float32, [128, 672, 21, 21], [])}
  buffer_map = {data_1: data, tensor_1: tensor} {
  attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 40656;
  allocate(tensor_3: Pointer(local float32), float32, [1]), storage_scope = local;
  attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 256 {
    tensor_3[0] = 0f32
    for (rv0: int32, 0, 3) {
      for (rv1: int32, 0, 3) {
        tensor_3[0] = ((float32*)tensor_3[0] + @tir.if_then_else(((((1 <= ((floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 121), 11)*2) + rv0)) && (((floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 121), 11)*2) + rv0) < 22)) && (1 <= ((floormod(((blockIdx.x*256) + threadIdx.x), 11)*2) + rv1))) && (((floormod(((blockIdx.x*256) + threadIdx.x), 11)*2) + rv1) < 22)), (float32*)data_2[((((((floordiv(((blockIdx.x*256) + threadIdx.x), 121)*441) + (floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 121), 11)*42)) + (rv0*21)) + (floormod(((blockIdx.x*256) + threadIdx.x), 11)*2)) + rv1) - 22)], 0f32, dtype=float32))
      }
    }
    tensor_2[((blockIdx.x*256) + threadIdx.x)] = ((float32*)tensor_3[0]*0.111111f32)
  }
}


; ModuleID = 'TVMAMDGPUModule'
source_filename = "TVMAMDGPUModule"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa-hcc"

; Function Attrs: nofree nounwind
define dllexport amdgpu_kernel void @default_function_kernel0(float addrspace(1)* noalias nocapture readonly %0, float addrspace(1)* noalias nocapture %1) local_unnamed_addr #0 {
entry:
  %2 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %3 = tail call i32 @llvm.amdgcn.workitem.id.x()
  %4 = shl i32 %2, 8
  %5 = add nsw i32 %4, %3
  %6 = srem i32 %5, 11
  %7 = shl nsw i32 %6, 1
  %8 = sdiv i32 %5, 121
  %9 = mul i32 %8, 121
  %.decomposed = sub i32 %5, %9
  %10 = sdiv i32 %.decomposed, 11
  %11 = shl nsw i32 %10, 1
  %12 = add nsw i32 %11, -1
  %13 = mul nsw i32 %10, 42
  %14 = mul nsw i32 %8, 441
  %15 = icmp ult i32 %12, 21
  %.off6 = add nsw i32 %7, -1
  %16 = icmp ult i32 %.off6, 21
  %17 = and i1 %15, %16
  br i1 %17, label %if_then, label %if_end

if_then:                                          ; preds = %entry
  %18 = add nuw nsw i32 %7, -22
  %19 = add i32 %18, %14
  %20 = add i32 %19, %13
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds float, float addrspace(1)* %0, i64 %21
  %23 = load float, float addrspace(1)* %22, align 4, !tbaa !4
  %phitmp = fadd float %23, 0.000000e+00
  br label %if_end

if_end:                                           ; preds = %entry, %if_then
  %24 = phi float [ %phitmp, %if_then ], [ 0.000000e+00, %entry ]
  %25 = icmp ult i32 %7, 21
  %26 = and i1 %15, %25
  br i1 %26, label %if_then.1, label %if_end.1

if_then.1:                                        ; preds = %if_end
  %27 = or i32 %7, 1
  %28 = add nsw i32 %27, -22
  %29 = add i32 %28, %14
  %30 = add i32 %29, %13
  %31 = sext i32 %30 to i64
  %32 = getelementptr inbounds float, float addrspace(1)* %0, i64 %31
  %33 = load float, float addrspace(1)* %32, align 4, !tbaa !4
  br label %if_end.1

if_end.1:                                         ; preds = %if_then.1, %if_end
  %34 = phi float [ %33, %if_then.1 ], [ 0.000000e+00, %if_end ]
  %35 = fadd float %24, %34
  %.off6.2 = or i32 %7, 1
  %36 = icmp ult i32 %.off6.2, 21
  %37 = and i1 %15, %36
  br i1 %37, label %if_then.2, label %if_end.2

if_then.2:                                        ; preds = %if_end.1
  %38 = add nsw i32 %7, -20
  %39 = add i32 %38, %14
  %40 = add i32 %39, %13
  %41 = sext i32 %40 to i64
  %42 = getelementptr inbounds float, float addrspace(1)* %0, i64 %41
  %43 = load float, float addrspace(1)* %42, align 4, !tbaa !4
  br label %if_end.2

if_end.2:                                         ; preds = %if_then.2, %if_end.1
  %44 = phi float [ %43, %if_then.2 ], [ 0.000000e+00, %if_end.1 ]
  %45 = fadd float %35, %44
  %46 = icmp ult i32 %11, 21
  %47 = and i1 %46, %16
  br i1 %47, label %if_then.19, label %if_end.110

if_then.19:                                       ; preds = %if_end.2
  %48 = add nuw nsw i32 %7, -22
  %49 = add i32 %48, %14
  %50 = add i32 %49, %13
  %51 = add i32 %50, 21
  %52 = sext i32 %51 to i64
  %53 = getelementptr inbounds float, float addrspace(1)* %0, i64 %52
  %54 = load float, float addrspace(1)* %53, align 4, !tbaa !4
  br label %if_end.110

if_end.110:                                       ; preds = %if_then.19, %if_end.2
  %55 = phi float [ %54, %if_then.19 ], [ 0.000000e+00, %if_end.2 ]
  %56 = fadd float %45, %55
  %57 = and i1 %46, %25
  br i1 %57, label %if_then.1.1, label %if_end.1.1

if_then.1.1:                                      ; preds = %if_end.110
  %58 = or i32 %7, 1
  %59 = add nsw i32 %58, -22
  %60 = add i32 %59, %14
  %61 = add i32 %60, %13
  %62 = add i32 %61, 21
  %63 = sext i32 %62 to i64
  %64 = getelementptr inbounds float, float addrspace(1)* %0, i64 %63
  %65 = load float, float addrspace(1)* %64, align 4, !tbaa !4
  br label %if_end.1.1

if_end.1.1:                                       ; preds = %if_then.1.1, %if_end.110
  %66 = phi float [ %65, %if_then.1.1 ], [ 0.000000e+00, %if_end.110 ]
  %67 = fadd float %56, %66
  %68 = and i1 %46, %36
  br i1 %68, label %if_then.2.1, label %if_end.2.1

if_then.2.1:                                      ; preds = %if_end.1.1
  %69 = add nsw i32 %7, -20
  %70 = add i32 %69, %14
  %71 = add i32 %70, %13
  %72 = add i32 %71, 21
  %73 = sext i32 %72 to i64
  %74 = getelementptr inbounds float, float addrspace(1)* %0, i64 %73
  %75 = load float, float addrspace(1)* %74, align 4, !tbaa !4
  br label %if_end.2.1

if_end.2.1:                                       ; preds = %if_then.2.1, %if_end.1.1
  %76 = phi float [ %75, %if_then.2.1 ], [ 0.000000e+00, %if_end.1.1 ]
  %77 = fadd float %67, %76
  %.off.2 = or i32 %11, 1
  %78 = icmp ult i32 %.off.2, 21
  %79 = and i1 %78, %16
  br i1 %79, label %if_then.212, label %if_end.213

if_then.212:                                      ; preds = %if_end.2.1
  %80 = add nuw nsw i32 %7, -22
  %81 = add i32 %80, %14
  %82 = add i32 %81, %13
  %83 = add i32 %82, 42
  %84 = sext i32 %83 to i64
  %85 = getelementptr inbounds float, float addrspace(1)* %0, i64 %84
  %86 = load float, float addrspace(1)* %85, align 4, !tbaa !4
  br label %if_end.213

if_end.213:                                       ; preds = %if_then.212, %if_end.2.1
  %87 = phi float [ %86, %if_then.212 ], [ 0.000000e+00, %if_end.2.1 ]
  %88 = fadd float %77, %87
  %89 = and i1 %78, %25
  br i1 %89, label %if_then.1.2, label %if_end.1.2

if_then.1.2:                                      ; preds = %if_end.213
  %90 = or i32 %7, 1
  %91 = add nsw i32 %90, -22
  %92 = add i32 %91, %14
  %93 = add i32 %92, %13
  %94 = add i32 %93, 42
  %95 = sext i32 %94 to i64
  %96 = getelementptr inbounds float, float addrspace(1)* %0, i64 %95
  %97 = load float, float addrspace(1)* %96, align 4, !tbaa !4
  br label %if_end.1.2

if_end.1.2:                                       ; preds = %if_then.1.2, %if_end.213
  %98 = phi float [ %97, %if_then.1.2 ], [ 0.000000e+00, %if_end.213 ]
  %99 = fadd float %88, %98
  %100 = and i1 %78, %36
  br i1 %100, label %if_then.2.2, label %if_end.2.2

if_then.2.2:                                      ; preds = %if_end.1.2
  %101 = add nsw i32 %7, -20
  %102 = add i32 %101, %14
  %103 = add i32 %102, %13
  %104 = add i32 %103, 42
  %105 = sext i32 %104 to i64
  %106 = getelementptr inbounds float, float addrspace(1)* %0, i64 %105
  %107 = load float, float addrspace(1)* %106, align 4, !tbaa !4
  br label %if_end.2.2

if_end.2.2:                                       ; preds = %if_then.2.2, %if_end.1.2
  %108 = phi float [ %107, %if_then.2.2 ], [ 0.000000e+00, %if_end.1.2 ]
  %109 = fadd float %99, %108
  %110 = fmul float %109, 0x3FBC71C720000000
  %111 = sext i32 %5 to i64
  %112 = getelementptr inbounds float, float addrspace(1)* %1, i64 %111
  store float %110, float addrspace(1)* %112, align 4, !tbaa !8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workgroup.id.x() #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nofree nounwind "amdgpu-flat-work-group-size"="1,1024" "no-nans-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 12.0.0 (/src/external/llvm-project/clang 1100ebe275a9dcc79a9abbda902b6f10738f2f5d)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"0x1a0cb70", !7, i64 0}
!7 = !{!"tvm-tbaa"}
!8 = !{!9, !9, i64 0}
!9 = !{!"float", !10, i64 0}
!10 = !{!"0x1a0cb30", !7, i64 0}

avg 128 42 83 83 3 1 SAME
Time cost of this operator: 0.0006455707
Lowered TIR:
@main = primfn(data_1: handle, tensor_1: handle) -> ()
  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
  buffers = {tensor: Buffer(tensor_2: Pointer(float32), float32, [128, 42, 83, 83], []),
             data: Buffer(data_2: Pointer(float32), float32, [128, 42, 83, 83], [])}
  buffer_map = {data_1: data, tensor_1: tensor} {
  attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 144669;
  allocate(tensor_3: Pointer(local float32), float32, [1]), storage_scope = local;
  attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 256 {
    tensor_3[0] = 0f32
    for (rv0: int32, 0, 3) {
      for (rv1: int32, 0, 3) {
        tensor_3[0] = ((float32*)tensor_3[0] + @tir.if_then_else(((((1 <= (floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 6889), 83) + rv0)) && ((floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 6889), 83) + rv0) < 84)) && (1 <= (rv1 + floormod(((blockIdx.x*256) + threadIdx.x), 83)))) && ((rv1 + floormod(((blockIdx.x*256) + threadIdx.x), 83)) < 84)), (float32*)data_2[(((((blockIdx.x*256) + (rv0*83)) + threadIdx.x) + rv1) - 84)], 0f32, dtype=float32))
      }
    }
    tensor_2[((blockIdx.x*256) + threadIdx.x)] = ((float32*)tensor_3[0]*0.111111f32)
  }
}


; ModuleID = 'TVMAMDGPUModule'
source_filename = "TVMAMDGPUModule"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa-hcc"

; Function Attrs: nofree nounwind
define dllexport amdgpu_kernel void @default_function_kernel0(float addrspace(1)* noalias nocapture readonly %0, float addrspace(1)* noalias nocapture %1) local_unnamed_addr #0 {
entry:
  %2 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %3 = tail call i32 @llvm.amdgcn.workitem.id.x()
  %4 = shl i32 %2, 8
  %5 = add i32 %4, %3
  %6 = srem i32 %5, 83
  %7 = srem i32 %5, 6889
  %8 = sdiv i32 %7, 83
  %9 = add nsw i32 %8, -1
  %10 = add nsw i32 %6, -1
  %11 = icmp ult i32 %9, 83
  %12 = icmp ult i32 %10, 83
  %13 = and i1 %11, %12
  br i1 %13, label %if_then, label %if_end

if_then:                                          ; preds = %entry
  %14 = add i32 %5, -84
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds float, float addrspace(1)* %0, i64 %15
  %17 = load float, float addrspace(1)* %16, align 4, !tbaa !4
  %phitmp = fadd float %17, 0.000000e+00
  br label %if_end

if_end:                                           ; preds = %entry, %if_then
  %18 = phi float [ %phitmp, %if_then ], [ 0.000000e+00, %entry ]
  %19 = icmp ult i32 %6, 83
  %20 = and i1 %11, %19
  br i1 %20, label %if_then.1, label %if_end.1

if_then.1:                                        ; preds = %if_end
  %21 = add i32 %5, -83
  %22 = sext i32 %21 to i64
  %23 = getelementptr inbounds float, float addrspace(1)* %0, i64 %22
  %24 = load float, float addrspace(1)* %23, align 4, !tbaa !4
  br label %if_end.1

if_end.1:                                         ; preds = %if_then.1, %if_end
  %25 = phi float [ %24, %if_then.1 ], [ 0.000000e+00, %if_end ]
  %26 = fadd float %18, %25
  %.off6.2 = add nsw i32 %6, 1
  %27 = icmp ult i32 %.off6.2, 83
  %28 = and i1 %11, %27
  br i1 %28, label %if_then.2, label %if_end.2

if_then.2:                                        ; preds = %if_end.1
  %29 = add i32 %5, -82
  %30 = sext i32 %29 to i64
  %31 = getelementptr inbounds float, float addrspace(1)* %0, i64 %30
  %32 = load float, float addrspace(1)* %31, align 4, !tbaa !4
  br label %if_end.2

if_end.2:                                         ; preds = %if_then.2, %if_end.1
  %33 = phi float [ %32, %if_then.2 ], [ 0.000000e+00, %if_end.1 ]
  %34 = fadd float %26, %33
  %35 = icmp ult i32 %8, 83
  %36 = and i1 %35, %12
  br i1 %36, label %if_then.19, label %if_end.110

if_then.19:                                       ; preds = %if_end.2
  %37 = add i32 %5, -1
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds float, float addrspace(1)* %0, i64 %38
  %40 = load float, float addrspace(1)* %39, align 4, !tbaa !4
  br label %if_end.110

if_end.110:                                       ; preds = %if_then.19, %if_end.2
  %41 = phi float [ %40, %if_then.19 ], [ 0.000000e+00, %if_end.2 ]
  %42 = fadd float %34, %41
  %43 = and i1 %35, %19
  br i1 %43, label %if_then.1.1, label %if_end.1.1

if_then.1.1:                                      ; preds = %if_end.110
  %44 = sext i32 %5 to i64
  %45 = getelementptr inbounds float, float addrspace(1)* %0, i64 %44
  %46 = load float, float addrspace(1)* %45, align 4, !tbaa !4
  br label %if_end.1.1

if_end.1.1:                                       ; preds = %if_then.1.1, %if_end.110
  %47 = phi float [ %46, %if_then.1.1 ], [ 0.000000e+00, %if_end.110 ]
  %48 = fadd float %42, %47
  %49 = and i1 %35, %27
  br i1 %49, label %if_then.2.1, label %if_end.2.1

if_then.2.1:                                      ; preds = %if_end.1.1
  %50 = add i32 %5, 1
  %51 = sext i32 %50 to i64
  %52 = getelementptr inbounds float, float addrspace(1)* %0, i64 %51
  %53 = load float, float addrspace(1)* %52, align 4, !tbaa !4
  br label %if_end.2.1

if_end.2.1:                                       ; preds = %if_then.2.1, %if_end.1.1
  %54 = phi float [ %53, %if_then.2.1 ], [ 0.000000e+00, %if_end.1.1 ]
  %55 = fadd float %48, %54
  %.off.2 = add nsw i32 %8, 1
  %56 = icmp ult i32 %.off.2, 83
  %57 = and i1 %56, %12
  br i1 %57, label %if_then.211, label %if_end.212

if_then.211:                                      ; preds = %if_end.2.1
  %58 = add i32 %5, 82
  %59 = sext i32 %58 to i64
  %60 = getelementptr inbounds float, float addrspace(1)* %0, i64 %59
  %61 = load float, float addrspace(1)* %60, align 4, !tbaa !4
  br label %if_end.212

if_end.212:                                       ; preds = %if_then.211, %if_end.2.1
  %62 = phi float [ %61, %if_then.211 ], [ 0.000000e+00, %if_end.2.1 ]
  %63 = fadd float %55, %62
  %64 = and i1 %56, %19
  br i1 %64, label %if_then.1.2, label %if_end.1.2

if_then.1.2:                                      ; preds = %if_end.212
  %65 = add i32 %5, 83
  %66 = sext i32 %65 to i64
  %67 = getelementptr inbounds float, float addrspace(1)* %0, i64 %66
  %68 = load float, float addrspace(1)* %67, align 4, !tbaa !4
  br label %if_end.1.2

if_end.1.2:                                       ; preds = %if_then.1.2, %if_end.212
  %69 = phi float [ %68, %if_then.1.2 ], [ 0.000000e+00, %if_end.212 ]
  %70 = fadd float %63, %69
  %71 = and i1 %56, %27
  br i1 %71, label %if_then.2.2, label %if_end.2.2

if_then.2.2:                                      ; preds = %if_end.1.2
  %72 = add i32 %5, 84
  %73 = sext i32 %72 to i64
  %74 = getelementptr inbounds float, float addrspace(1)* %0, i64 %73
  %75 = load float, float addrspace(1)* %74, align 4, !tbaa !4
  br label %if_end.2.2

if_end.2.2:                                       ; preds = %if_then.2.2, %if_end.1.2
  %76 = phi float [ %75, %if_then.2.2 ], [ 0.000000e+00, %if_end.1.2 ]
  %77 = fadd float %70, %76
  %78 = fmul float %77, 0x3FBC71C720000000
  %79 = sext i32 %5 to i64
  %80 = getelementptr inbounds float, float addrspace(1)* %1, i64 %79
  store float %78, float addrspace(1)* %80, align 4, !tbaa !8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workgroup.id.x() #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nofree nounwind "amdgpu-flat-work-group-size"="1,1024" "no-nans-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 12.0.0 (/src/external/llvm-project/clang 1100ebe275a9dcc79a9abbda902b6f10738f2f5d)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"0x2aa29d0", !7, i64 0}
!7 = !{!"tvm-tbaa"}
!8 = !{!9, !9, i64 0}
!9 = !{!"float", !10, i64 0}
!10 = !{!"0x2aa2990", !7, i64 0}

avg 128 1008 42 42 1 2 VALID
Time cost of this operator: 0.0010618392
Lowered TIR:
@main = primfn(data_1: handle, tensor_1: handle) -> ()
  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
  buffers = {tensor: Buffer(tensor_2: Pointer(float32), float32, [128, 1008, 21, 21], []),
             data: Buffer(data_2: Pointer(float32), float32, [128, 1008, 42, 42], [])}
  buffer_map = {data_1: data, tensor_1: tensor} {
  attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 222264;
  allocate(tensor_3: Pointer(local float32), float32, [1]), storage_scope = local;
  attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 256 {
    tensor_3[0] = 0f32
    tensor_3[0] = ((float32*)tensor_3[0] + (float32*)data_2[((floordiv(((blockIdx.x*256) + threadIdx.x), 21)*84) + (floormod(((blockIdx.x*256) + threadIdx.x), 21)*2))])
    tensor_2[((blockIdx.x*256) + threadIdx.x)] = (float32*)tensor_3[0]
  }
}


; ModuleID = 'TVMAMDGPUModule'
source_filename = "TVMAMDGPUModule"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa-hcc"

; Function Attrs: nofree nounwind
define dllexport amdgpu_kernel void @default_function_kernel0(float addrspace(1)* noalias nocapture readonly %0, float addrspace(1)* noalias nocapture %1) local_unnamed_addr #0 {
entry:
  %2 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %3 = tail call i32 @llvm.amdgcn.workitem.id.x()
  %4 = shl nsw i32 %2, 8
  %5 = add nsw i32 %4, %3
  %6 = sdiv i32 %5, 21
  %7 = mul i32 %6, 21
  %.decomposed = sub i32 %5, %7
  %8 = shl nsw i32 %.decomposed, 1
  %9 = mul nsw i32 %6, 84
  %10 = add nsw i32 %9, %8
  %11 = sext i32 %10 to i64
  %12 = getelementptr inbounds float, float addrspace(1)* %0, i64 %11
  %13 = load float, float addrspace(1)* %12, align 4, !tbaa !4
  %14 = fadd float %13, 0.000000e+00
  %15 = sext i32 %5 to i64
  %16 = getelementptr inbounds float, float addrspace(1)* %1, i64 %15
  store float %14, float addrspace(1)* %16, align 4, !tbaa !8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workgroup.id.x() #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nofree nounwind "amdgpu-flat-work-group-size"="1,1024" "no-nans-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 12.0.0 (/src/external/llvm-project/clang 1100ebe275a9dcc79a9abbda902b6f10738f2f5d)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"0x2762180", !7, i64 0}
!7 = !{!"tvm-tbaa"}
!8 = !{!9, !9, i64 0}
!9 = !{!"float", !10, i64 0}
!10 = !{!"0x275bc20", !7, i64 0}

avg 128 336 42 42 3 2 SAME
Time cost of this operator: 0.0007960061
Lowered TIR:
@main = primfn(data_1: handle, tensor_1: handle) -> ()
  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
  buffers = {tensor: Buffer(tensor_2: Pointer(float32), float32, [128, 336, 21, 21], []),
             data: Buffer(data_2: Pointer(float32), float32, [128, 336, 42, 42], [])}
  buffer_map = {data_1: data, tensor_1: tensor} {
  attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 74088;
  allocate(tensor_3: Pointer(local float32), float32, [1]), storage_scope = local;
  attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 256 {
    tensor_3[0] = 0f32
    for (rv0: int32, 0, 3) {
      for (rv1: int32, 0, 3) {
        tensor_3[0] = ((float32*)tensor_3[0] + @tir.if_then_else(((1 <= ((floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 441), 21)*2) + rv0)) && (1 <= ((floormod(((blockIdx.x*256) + threadIdx.x), 21)*2) + rv1))), (float32*)data_2[(((((floordiv(((blockIdx.x*256) + threadIdx.x), 21)*84) + (rv0*42)) + (floormod(((blockIdx.x*256) + threadIdx.x), 21)*2)) + rv1) - 43)], 0f32, dtype=float32))
      }
    }
    tensor_2[((blockIdx.x*256) + threadIdx.x)] = ((float32*)tensor_3[0]*0.111111f32)
  }
}


; ModuleID = 'TVMAMDGPUModule'
source_filename = "TVMAMDGPUModule"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa-hcc"

; Function Attrs: nofree nounwind
define dllexport amdgpu_kernel void @default_function_kernel0(float addrspace(1)* noalias nocapture readonly %0, float addrspace(1)* noalias nocapture %1) local_unnamed_addr #0 {
entry:
  %2 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %3 = tail call i32 @llvm.amdgcn.workitem.id.x()
  %4 = shl i32 %2, 8
  %5 = add nsw i32 %4, %3
  %6 = sdiv i32 %5, 21
  %7 = mul i32 %6, 21
  %.decomposed = sub i32 %5, %7
  %8 = shl nsw i32 %.decomposed, 1
  %9 = srem i32 %5, 441
  %10 = sdiv i32 %9, 21
  %11 = shl nsw i32 %10, 1
  %12 = mul nsw i32 %6, 84
  %13 = icmp sgt i32 %9, 20
  %14 = icmp sgt i32 %.decomposed, 0
  %15 = and i1 %13, %14
  br i1 %15, label %if_then, label %if_end

if_then:                                          ; preds = %entry
  %16 = add nsw i32 %8, -43
  %17 = add i32 %16, %12
  %18 = sext i32 %17 to i64
  %19 = getelementptr inbounds float, float addrspace(1)* %0, i64 %18
  %20 = load float, float addrspace(1)* %19, align 4, !tbaa !4
  %phitmp = fadd float %20, 0.000000e+00
  br label %if_end

if_end:                                           ; preds = %entry, %if_then
  %21 = phi float [ %phitmp, %if_then ], [ 0.000000e+00, %entry ]
  %22 = or i32 %8, 1
  %23 = icmp sgt i32 %22, 0
  %24 = and i1 %13, %23
  br i1 %24, label %if_then.1, label %if_end.1

if_then.1:                                        ; preds = %if_end
  %25 = add nsw i32 %22, -43
  %26 = add i32 %25, %12
  %27 = sext i32 %26 to i64
  %28 = getelementptr inbounds float, float addrspace(1)* %0, i64 %27
  %29 = load float, float addrspace(1)* %28, align 4, !tbaa !4
  br label %if_end.1

if_end.1:                                         ; preds = %if_then.1, %if_end
  %30 = phi float [ %29, %if_then.1 ], [ 0.000000e+00, %if_end ]
  %31 = fadd float %21, %30
  %32 = icmp sgt i32 %.decomposed, -1
  %33 = and i1 %13, %32
  br i1 %33, label %if_then.2, label %if_end.2

if_then.2:                                        ; preds = %if_end.1
  %34 = add nsw i32 %8, -41
  %35 = add i32 %34, %12
  %36 = sext i32 %35 to i64
  %37 = getelementptr inbounds float, float addrspace(1)* %0, i64 %36
  %38 = load float, float addrspace(1)* %37, align 4, !tbaa !4
  br label %if_end.2

if_end.2:                                         ; preds = %if_then.2, %if_end.1
  %39 = phi float [ %38, %if_then.2 ], [ 0.000000e+00, %if_end.1 ]
  %40 = fadd float %31, %39
  %41 = or i32 %11, 1
  %42 = icmp sgt i32 %41, 0
  %43 = and i1 %42, %14
  br i1 %43, label %if_then.18, label %if_end.19

if_then.18:                                       ; preds = %if_end.2
  %44 = add nsw i32 %8, -43
  %45 = add i32 %44, %12
  %46 = add i32 %45, 42
  %47 = sext i32 %46 to i64
  %48 = getelementptr inbounds float, float addrspace(1)* %0, i64 %47
  %49 = load float, float addrspace(1)* %48, align 4, !tbaa !4
  br label %if_end.19

if_end.19:                                        ; preds = %if_then.18, %if_end.2
  %50 = phi float [ %49, %if_then.18 ], [ 0.000000e+00, %if_end.2 ]
  %51 = fadd float %40, %50
  %52 = and i1 %42, %23
  br i1 %52, label %if_then.1.1, label %if_end.1.1

if_then.1.1:                                      ; preds = %if_end.19
  %53 = add nsw i32 %22, -43
  %54 = add i32 %53, %12
  %55 = add i32 %54, 42
  %56 = sext i32 %55 to i64
  %57 = getelementptr inbounds float, float addrspace(1)* %0, i64 %56
  %58 = load float, float addrspace(1)* %57, align 4, !tbaa !4
  br label %if_end.1.1

if_end.1.1:                                       ; preds = %if_then.1.1, %if_end.19
  %59 = phi float [ %58, %if_then.1.1 ], [ 0.000000e+00, %if_end.19 ]
  %60 = fadd float %51, %59
  %61 = and i1 %42, %32
  br i1 %61, label %if_then.2.1, label %if_end.2.1

if_then.2.1:                                      ; preds = %if_end.1.1
  %62 = add nsw i32 %8, -41
  %63 = add i32 %62, %12
  %64 = add i32 %63, 42
  %65 = sext i32 %64 to i64
  %66 = getelementptr inbounds float, float addrspace(1)* %0, i64 %65
  %67 = load float, float addrspace(1)* %66, align 4, !tbaa !4
  br label %if_end.2.1

if_end.2.1:                                       ; preds = %if_then.2.1, %if_end.1.1
  %68 = phi float [ %67, %if_then.2.1 ], [ 0.000000e+00, %if_end.1.1 ]
  %69 = fadd float %60, %68
  %70 = icmp sgt i32 %9, -21
  %71 = and i1 %70, %14
  br i1 %71, label %if_then.210, label %if_end.211

if_then.210:                                      ; preds = %if_end.2.1
  %72 = add nsw i32 %8, -43
  %73 = add i32 %72, %12
  %74 = add i32 %73, 84
  %75 = sext i32 %74 to i64
  %76 = getelementptr inbounds float, float addrspace(1)* %0, i64 %75
  %77 = load float, float addrspace(1)* %76, align 4, !tbaa !4
  br label %if_end.211

if_end.211:                                       ; preds = %if_then.210, %if_end.2.1
  %78 = phi float [ %77, %if_then.210 ], [ 0.000000e+00, %if_end.2.1 ]
  %79 = fadd float %69, %78
  %80 = and i1 %70, %23
  br i1 %80, label %if_then.1.2, label %if_end.1.2

if_then.1.2:                                      ; preds = %if_end.211
  %81 = add nsw i32 %22, -43
  %82 = add i32 %81, %12
  %83 = add i32 %82, 84
  %84 = sext i32 %83 to i64
  %85 = getelementptr inbounds float, float addrspace(1)* %0, i64 %84
  %86 = load float, float addrspace(1)* %85, align 4, !tbaa !4
  br label %if_end.1.2

if_end.1.2:                                       ; preds = %if_then.1.2, %if_end.211
  %87 = phi float [ %86, %if_then.1.2 ], [ 0.000000e+00, %if_end.211 ]
  %88 = fadd float %79, %87
  %89 = and i1 %70, %32
  br i1 %89, label %if_then.2.2, label %if_end.2.2

if_then.2.2:                                      ; preds = %if_end.1.2
  %90 = add nsw i32 %8, -41
  %91 = add i32 %90, %12
  %92 = add i32 %91, 84
  %93 = sext i32 %92 to i64
  %94 = getelementptr inbounds float, float addrspace(1)* %0, i64 %93
  %95 = load float, float addrspace(1)* %94, align 4, !tbaa !4
  br label %if_end.2.2

if_end.2.2:                                       ; preds = %if_then.2.2, %if_end.1.2
  %96 = phi float [ %95, %if_then.2.2 ], [ 0.000000e+00, %if_end.1.2 ]
  %97 = fadd float %88, %96
  %98 = fmul float %97, 0x3FBC71C720000000
  %99 = sext i32 %5 to i64
  %100 = getelementptr inbounds float, float addrspace(1)* %1, i64 %99
  store float %98, float addrspace(1)* %100, align 4, !tbaa !8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workgroup.id.x() #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nofree nounwind "amdgpu-flat-work-group-size"="1,1024" "no-nans-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 12.0.0 (/src/external/llvm-project/clang 1100ebe275a9dcc79a9abbda902b6f10738f2f5d)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"0x2487e30", !7, i64 0}
!7 = !{!"tvm-tbaa"}
!8 = !{!9, !9, i64 0}
!9 = !{!"float", !10, i64 0}
!10 = !{!"0x2487df0", !7, i64 0}

avg 128 84 83 83 3 2 SAME
Time cost of this operator: 0.0008195757
Lowered TIR:
@main = primfn(data_1: handle, tensor_1: handle) -> ()
  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
  buffers = {tensor: Buffer(tensor_2: Pointer(float32), float32, [128, 84, 42, 42], []),
             data: Buffer(data_2: Pointer(float32), float32, [128, 84, 83, 83], [])}
  buffer_map = {data_1: data, tensor_1: tensor} {
  attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 74088;
  allocate(tensor_3: Pointer(local float32), float32, [1]), storage_scope = local;
  attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 256 {
    tensor_3[0] = 0f32
    for (rv0: int32, 0, 3) {
      for (rv1: int32, 0, 3) {
        tensor_3[0] = ((float32*)tensor_3[0] + @tir.if_then_else(((((1 <= ((floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 1764), 42)*2) + rv0)) && (((floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 1764), 42)*2) + rv0) < 84)) && (1 <= ((floormod(((blockIdx.x*256) + threadIdx.x), 42)*2) + rv1))) && (((floormod(((blockIdx.x*256) + threadIdx.x), 42)*2) + rv1) < 84)), (float32*)data_2[((((((floordiv(((blockIdx.x*256) + threadIdx.x), 1764)*6889) + (floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 1764), 42)*166)) + (rv0*83)) + (floormod(((blockIdx.x*256) + threadIdx.x), 42)*2)) + rv1) - 84)], 0f32, dtype=float32))
      }
    }
    tensor_2[((blockIdx.x*256) + threadIdx.x)] = ((float32*)tensor_3[0]*0.111111f32)
  }
}


; ModuleID = 'TVMAMDGPUModule'
source_filename = "TVMAMDGPUModule"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa-hcc"

; Function Attrs: nofree nounwind
define dllexport amdgpu_kernel void @default_function_kernel0(float addrspace(1)* noalias nocapture readonly %0, float addrspace(1)* noalias nocapture %1) local_unnamed_addr #0 {
entry:
  %2 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %3 = tail call i32 @llvm.amdgcn.workitem.id.x()
  %4 = shl i32 %2, 8
  %5 = add nsw i32 %4, %3
  %6 = srem i32 %5, 42
  %7 = shl nsw i32 %6, 1
  %8 = sdiv i32 %5, 1764
  %9 = mul i32 %8, 1764
  %.decomposed = sub i32 %5, %9
  %10 = sdiv i32 %.decomposed, 42
  %11 = shl nsw i32 %10, 1
  %12 = add nsw i32 %11, -1
  %13 = mul nsw i32 %10, 166
  %14 = mul nsw i32 %8, 6889
  %15 = icmp ult i32 %12, 83
  %.off6 = add nsw i32 %7, -1
  %16 = icmp ult i32 %.off6, 83
  %17 = and i1 %15, %16
  br i1 %17, label %if_then, label %if_end

if_then:                                          ; preds = %entry
  %18 = add nuw nsw i32 %7, -84
  %19 = add i32 %18, %14
  %20 = add i32 %19, %13
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds float, float addrspace(1)* %0, i64 %21
  %23 = load float, float addrspace(1)* %22, align 4, !tbaa !4
  %phitmp = fadd float %23, 0.000000e+00
  br label %if_end

if_end:                                           ; preds = %entry, %if_then
  %24 = phi float [ %phitmp, %if_then ], [ 0.000000e+00, %entry ]
  %25 = icmp ult i32 %7, 83
  %26 = and i1 %15, %25
  br i1 %26, label %if_then.1, label %if_end.1

if_then.1:                                        ; preds = %if_end
  %27 = or i32 %7, 1
  %28 = add nsw i32 %27, -84
  %29 = add i32 %28, %14
  %30 = add i32 %29, %13
  %31 = sext i32 %30 to i64
  %32 = getelementptr inbounds float, float addrspace(1)* %0, i64 %31
  %33 = load float, float addrspace(1)* %32, align 4, !tbaa !4
  br label %if_end.1

if_end.1:                                         ; preds = %if_then.1, %if_end
  %34 = phi float [ %33, %if_then.1 ], [ 0.000000e+00, %if_end ]
  %35 = fadd float %24, %34
  %.off6.2 = or i32 %7, 1
  %36 = icmp ult i32 %.off6.2, 83
  %37 = and i1 %15, %36
  br i1 %37, label %if_then.2, label %if_end.2

if_then.2:                                        ; preds = %if_end.1
  %38 = add nsw i32 %7, -82
  %39 = add i32 %38, %14
  %40 = add i32 %39, %13
  %41 = sext i32 %40 to i64
  %42 = getelementptr inbounds float, float addrspace(1)* %0, i64 %41
  %43 = load float, float addrspace(1)* %42, align 4, !tbaa !4
  br label %if_end.2

if_end.2:                                         ; preds = %if_then.2, %if_end.1
  %44 = phi float [ %43, %if_then.2 ], [ 0.000000e+00, %if_end.1 ]
  %45 = fadd float %35, %44
  %46 = icmp ult i32 %11, 83
  %47 = and i1 %46, %16
  br i1 %47, label %if_then.19, label %if_end.110

if_then.19:                                       ; preds = %if_end.2
  %48 = add nuw nsw i32 %7, -84
  %49 = add i32 %48, %14
  %50 = add i32 %49, %13
  %51 = add i32 %50, 83
  %52 = sext i32 %51 to i64
  %53 = getelementptr inbounds float, float addrspace(1)* %0, i64 %52
  %54 = load float, float addrspace(1)* %53, align 4, !tbaa !4
  br label %if_end.110

if_end.110:                                       ; preds = %if_then.19, %if_end.2
  %55 = phi float [ %54, %if_then.19 ], [ 0.000000e+00, %if_end.2 ]
  %56 = fadd float %45, %55
  %57 = and i1 %46, %25
  br i1 %57, label %if_then.1.1, label %if_end.1.1

if_then.1.1:                                      ; preds = %if_end.110
  %58 = or i32 %7, 1
  %59 = add nsw i32 %58, -84
  %60 = add i32 %59, %14
  %61 = add i32 %60, %13
  %62 = add i32 %61, 83
  %63 = sext i32 %62 to i64
  %64 = getelementptr inbounds float, float addrspace(1)* %0, i64 %63
  %65 = load float, float addrspace(1)* %64, align 4, !tbaa !4
  br label %if_end.1.1

if_end.1.1:                                       ; preds = %if_then.1.1, %if_end.110
  %66 = phi float [ %65, %if_then.1.1 ], [ 0.000000e+00, %if_end.110 ]
  %67 = fadd float %56, %66
  %68 = and i1 %46, %36
  br i1 %68, label %if_then.2.1, label %if_end.2.1

if_then.2.1:                                      ; preds = %if_end.1.1
  %69 = add nsw i32 %7, -82
  %70 = add i32 %69, %14
  %71 = add i32 %70, %13
  %72 = add i32 %71, 83
  %73 = sext i32 %72 to i64
  %74 = getelementptr inbounds float, float addrspace(1)* %0, i64 %73
  %75 = load float, float addrspace(1)* %74, align 4, !tbaa !4
  br label %if_end.2.1

if_end.2.1:                                       ; preds = %if_then.2.1, %if_end.1.1
  %76 = phi float [ %75, %if_then.2.1 ], [ 0.000000e+00, %if_end.1.1 ]
  %77 = fadd float %67, %76
  %.off.2 = or i32 %11, 1
  %78 = icmp ult i32 %.off.2, 83
  %79 = and i1 %78, %16
  br i1 %79, label %if_then.212, label %if_end.213

if_then.212:                                      ; preds = %if_end.2.1
  %80 = add nuw nsw i32 %7, -84
  %81 = add i32 %80, %14
  %82 = add i32 %81, %13
  %83 = add i32 %82, 166
  %84 = sext i32 %83 to i64
  %85 = getelementptr inbounds float, float addrspace(1)* %0, i64 %84
  %86 = load float, float addrspace(1)* %85, align 4, !tbaa !4
  br label %if_end.213

if_end.213:                                       ; preds = %if_then.212, %if_end.2.1
  %87 = phi float [ %86, %if_then.212 ], [ 0.000000e+00, %if_end.2.1 ]
  %88 = fadd float %77, %87
  %89 = and i1 %78, %25
  br i1 %89, label %if_then.1.2, label %if_end.1.2

if_then.1.2:                                      ; preds = %if_end.213
  %90 = or i32 %7, 1
  %91 = add nsw i32 %90, -84
  %92 = add i32 %91, %14
  %93 = add i32 %92, %13
  %94 = add i32 %93, 166
  %95 = sext i32 %94 to i64
  %96 = getelementptr inbounds float, float addrspace(1)* %0, i64 %95
  %97 = load float, float addrspace(1)* %96, align 4, !tbaa !4
  br label %if_end.1.2

if_end.1.2:                                       ; preds = %if_then.1.2, %if_end.213
  %98 = phi float [ %97, %if_then.1.2 ], [ 0.000000e+00, %if_end.213 ]
  %99 = fadd float %88, %98
  %100 = and i1 %78, %36
  br i1 %100, label %if_then.2.2, label %if_end.2.2

if_then.2.2:                                      ; preds = %if_end.1.2
  %101 = add nsw i32 %7, -82
  %102 = add i32 %101, %14
  %103 = add i32 %102, %13
  %104 = add i32 %103, 166
  %105 = sext i32 %104 to i64
  %106 = getelementptr inbounds float, float addrspace(1)* %0, i64 %105
  %107 = load float, float addrspace(1)* %106, align 4, !tbaa !4
  br label %if_end.2.2

if_end.2.2:                                       ; preds = %if_then.2.2, %if_end.1.2
  %108 = phi float [ %107, %if_then.2.2 ], [ 0.000000e+00, %if_end.1.2 ]
  %109 = fadd float %99, %108
  %110 = fmul float %109, 0x3FBC71C720000000
  %111 = sext i32 %5 to i64
  %112 = getelementptr inbounds float, float addrspace(1)* %1, i64 %111
  store float %110, float addrspace(1)* %112, align 4, !tbaa !8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workgroup.id.x() #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nofree nounwind "amdgpu-flat-work-group-size"="1,1024" "no-nans-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 12.0.0 (/src/external/llvm-project/clang 1100ebe275a9dcc79a9abbda902b6f10738f2f5d)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"0x2b58b50", !7, i64 0}
!7 = !{!"tvm-tbaa"}
!8 = !{!9, !9, i64 0}
!9 = !{!"float", !10, i64 0}
!10 = !{!"0x2b58b10", !7, i64 0}

avg 128 672 11 11 3 1 SAME
Time cost of this operator: 0.0001774360
Lowered TIR:
@main = primfn(data_1: handle, tensor_1: handle) -> ()
  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
  buffers = {tensor: Buffer(tensor_2: Pointer(float32), float32, [128, 672, 11, 11], []),
             data: Buffer(data_2: Pointer(float32), float32, [128, 672, 11, 11], [])}
  buffer_map = {data_1: data, tensor_1: tensor} {
  attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 40656;
  allocate(tensor_3: Pointer(local float32), float32, [1]), storage_scope = local;
  attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 256 {
    tensor_3[0] = 0f32
    for (rv0: int32, 0, 3) {
      for (rv1: int32, 0, 3) {
        tensor_3[0] = ((float32*)tensor_3[0] + @tir.if_then_else(((((1 <= (floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 121), 11) + rv0)) && ((floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 121), 11) + rv0) < 12)) && (1 <= (rv1 + floormod(((blockIdx.x*256) + threadIdx.x), 11)))) && ((rv1 + floormod(((blockIdx.x*256) + threadIdx.x), 11)) < 12)), (float32*)data_2[(((((blockIdx.x*256) + (rv0*11)) + threadIdx.x) + rv1) - 12)], 0f32, dtype=float32))
      }
    }
    tensor_2[((blockIdx.x*256) + threadIdx.x)] = ((float32*)tensor_3[0]*0.111111f32)
  }
}


; ModuleID = 'TVMAMDGPUModule'
source_filename = "TVMAMDGPUModule"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa-hcc"

; Function Attrs: nofree nounwind
define dllexport amdgpu_kernel void @default_function_kernel0(float addrspace(1)* noalias nocapture readonly %0, float addrspace(1)* noalias nocapture %1) local_unnamed_addr #0 {
entry:
  %2 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %3 = tail call i32 @llvm.amdgcn.workitem.id.x()
  %4 = shl i32 %2, 8
  %5 = add i32 %4, %3
  %6 = srem i32 %5, 11
  %7 = srem i32 %5, 121
  %8 = sdiv i32 %7, 11
  %9 = add nsw i32 %8, -1
  %10 = add nsw i32 %6, -1
  %11 = icmp ult i32 %9, 11
  %12 = icmp ult i32 %10, 11
  %13 = and i1 %11, %12
  br i1 %13, label %if_then, label %if_end

if_then:                                          ; preds = %entry
  %14 = add i32 %5, -12
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds float, float addrspace(1)* %0, i64 %15
  %17 = load float, float addrspace(1)* %16, align 4, !tbaa !4
  %phitmp = fadd float %17, 0.000000e+00
  br label %if_end

if_end:                                           ; preds = %entry, %if_then
  %18 = phi float [ %phitmp, %if_then ], [ 0.000000e+00, %entry ]
  %19 = icmp ult i32 %6, 11
  %20 = and i1 %11, %19
  br i1 %20, label %if_then.1, label %if_end.1

if_then.1:                                        ; preds = %if_end
  %21 = add i32 %5, -11
  %22 = sext i32 %21 to i64
  %23 = getelementptr inbounds float, float addrspace(1)* %0, i64 %22
  %24 = load float, float addrspace(1)* %23, align 4, !tbaa !4
  br label %if_end.1

if_end.1:                                         ; preds = %if_then.1, %if_end
  %25 = phi float [ %24, %if_then.1 ], [ 0.000000e+00, %if_end ]
  %26 = fadd float %18, %25
  %.off6.2 = add nsw i32 %6, 1
  %27 = icmp ult i32 %.off6.2, 11
  %28 = and i1 %11, %27
  br i1 %28, label %if_then.2, label %if_end.2

if_then.2:                                        ; preds = %if_end.1
  %29 = add i32 %5, -10
  %30 = sext i32 %29 to i64
  %31 = getelementptr inbounds float, float addrspace(1)* %0, i64 %30
  %32 = load float, float addrspace(1)* %31, align 4, !tbaa !4
  br label %if_end.2

if_end.2:                                         ; preds = %if_then.2, %if_end.1
  %33 = phi float [ %32, %if_then.2 ], [ 0.000000e+00, %if_end.1 ]
  %34 = fadd float %26, %33
  %35 = icmp ult i32 %8, 11
  %36 = and i1 %35, %12
  br i1 %36, label %if_then.19, label %if_end.110

if_then.19:                                       ; preds = %if_end.2
  %37 = add i32 %5, -1
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds float, float addrspace(1)* %0, i64 %38
  %40 = load float, float addrspace(1)* %39, align 4, !tbaa !4
  br label %if_end.110

if_end.110:                                       ; preds = %if_then.19, %if_end.2
  %41 = phi float [ %40, %if_then.19 ], [ 0.000000e+00, %if_end.2 ]
  %42 = fadd float %34, %41
  %43 = and i1 %35, %19
  br i1 %43, label %if_then.1.1, label %if_end.1.1

if_then.1.1:                                      ; preds = %if_end.110
  %44 = sext i32 %5 to i64
  %45 = getelementptr inbounds float, float addrspace(1)* %0, i64 %44
  %46 = load float, float addrspace(1)* %45, align 4, !tbaa !4
  br label %if_end.1.1

if_end.1.1:                                       ; preds = %if_then.1.1, %if_end.110
  %47 = phi float [ %46, %if_then.1.1 ], [ 0.000000e+00, %if_end.110 ]
  %48 = fadd float %42, %47
  %49 = and i1 %35, %27
  br i1 %49, label %if_then.2.1, label %if_end.2.1

if_then.2.1:                                      ; preds = %if_end.1.1
  %50 = add i32 %5, 1
  %51 = sext i32 %50 to i64
  %52 = getelementptr inbounds float, float addrspace(1)* %0, i64 %51
  %53 = load float, float addrspace(1)* %52, align 4, !tbaa !4
  br label %if_end.2.1

if_end.2.1:                                       ; preds = %if_then.2.1, %if_end.1.1
  %54 = phi float [ %53, %if_then.2.1 ], [ 0.000000e+00, %if_end.1.1 ]
  %55 = fadd float %48, %54
  %.off.2 = add nsw i32 %8, 1
  %56 = icmp ult i32 %.off.2, 11
  %57 = and i1 %56, %12
  br i1 %57, label %if_then.211, label %if_end.212

if_then.211:                                      ; preds = %if_end.2.1
  %58 = add i32 %5, 10
  %59 = sext i32 %58 to i64
  %60 = getelementptr inbounds float, float addrspace(1)* %0, i64 %59
  %61 = load float, float addrspace(1)* %60, align 4, !tbaa !4
  br label %if_end.212

if_end.212:                                       ; preds = %if_then.211, %if_end.2.1
  %62 = phi float [ %61, %if_then.211 ], [ 0.000000e+00, %if_end.2.1 ]
  %63 = fadd float %55, %62
  %64 = and i1 %56, %19
  br i1 %64, label %if_then.1.2, label %if_end.1.2

if_then.1.2:                                      ; preds = %if_end.212
  %65 = add i32 %5, 11
  %66 = sext i32 %65 to i64
  %67 = getelementptr inbounds float, float addrspace(1)* %0, i64 %66
  %68 = load float, float addrspace(1)* %67, align 4, !tbaa !4
  br label %if_end.1.2

if_end.1.2:                                       ; preds = %if_then.1.2, %if_end.212
  %69 = phi float [ %68, %if_then.1.2 ], [ 0.000000e+00, %if_end.212 ]
  %70 = fadd float %63, %69
  %71 = and i1 %56, %27
  br i1 %71, label %if_then.2.2, label %if_end.2.2

if_then.2.2:                                      ; preds = %if_end.1.2
  %72 = add i32 %5, 12
  %73 = sext i32 %72 to i64
  %74 = getelementptr inbounds float, float addrspace(1)* %0, i64 %73
  %75 = load float, float addrspace(1)* %74, align 4, !tbaa !4
  br label %if_end.2.2

if_end.2.2:                                       ; preds = %if_then.2.2, %if_end.1.2
  %76 = phi float [ %75, %if_then.2.2 ], [ 0.000000e+00, %if_end.1.2 ]
  %77 = fadd float %70, %76
  %78 = fmul float %77, 0x3FBC71C720000000
  %79 = sext i32 %5 to i64
  %80 = getelementptr inbounds float, float addrspace(1)* %1, i64 %79
  store float %78, float addrspace(1)* %80, align 4, !tbaa !8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workgroup.id.x() #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nofree nounwind "amdgpu-flat-work-group-size"="1,1024" "no-nans-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 12.0.0 (/src/external/llvm-project/clang 1100ebe275a9dcc79a9abbda902b6f10738f2f5d)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"0x285b870", !7, i64 0}
!7 = !{!"tvm-tbaa"}
!8 = !{!9, !9, i64 0}
!9 = !{!"float", !10, i64 0}
!10 = !{!"0x285b830", !7, i64 0}

avg 128 96 165 165 1 2 VALID
Time cost of this operator: 0.0013939819
Lowered TIR:
@main = primfn(data_1: handle, tensor_1: handle) -> ()
  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
  buffers = {tensor: Buffer(tensor_2: Pointer(float32), float32, [128, 96, 83, 83], []),
             data: Buffer(data_2: Pointer(float32), float32, [128, 96, 165, 165], [])}
  buffer_map = {data_1: data, tensor_1: tensor} {
  attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 330672;
  allocate(tensor_3: Pointer(local float32), float32, [1]), storage_scope = local;
  attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 256 {
    tensor_3[0] = 0f32
    tensor_3[0] = ((float32*)tensor_3[0] + (float32*)data_2[(((floordiv(((blockIdx.x*256) + threadIdx.x), 6889)*27225) + (floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 6889), 83)*330)) + (floormod(((blockIdx.x*256) + threadIdx.x), 83)*2))])
    tensor_2[((blockIdx.x*256) + threadIdx.x)] = (float32*)tensor_3[0]
  }
}


; ModuleID = 'TVMAMDGPUModule'
source_filename = "TVMAMDGPUModule"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa-hcc"

; Function Attrs: nofree nounwind
define dllexport amdgpu_kernel void @default_function_kernel0(float addrspace(1)* noalias nocapture readonly %0, float addrspace(1)* noalias nocapture %1) local_unnamed_addr #0 {
entry:
  %2 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %3 = tail call i32 @llvm.amdgcn.workitem.id.x()
  %4 = shl nsw i32 %2, 8
  %5 = add nsw i32 %4, %3
  %6 = srem i32 %5, 83
  %7 = shl nsw i32 %6, 1
  %8 = sdiv i32 %5, 6889
  %9 = mul i32 %8, 6889
  %.decomposed = sub i32 %5, %9
  %10 = sdiv i32 %.decomposed, 83
  %11 = mul nsw i32 %10, 330
  %12 = mul nsw i32 %8, 27225
  %13 = add i32 %7, %12
  %14 = add i32 %13, %11
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds float, float addrspace(1)* %0, i64 %15
  %17 = load float, float addrspace(1)* %16, align 4, !tbaa !4
  %18 = fadd float %17, 0.000000e+00
  %19 = sext i32 %5 to i64
  %20 = getelementptr inbounds float, float addrspace(1)* %1, i64 %19
  store float %18, float addrspace(1)* %20, align 4, !tbaa !8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workgroup.id.x() #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nofree nounwind "amdgpu-flat-work-group-size"="1,1024" "no-nans-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 12.0.0 (/src/external/llvm-project/clang 1100ebe275a9dcc79a9abbda902b6f10738f2f5d)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"0x1931f70", !7, i64 0}
!7 = !{!"tvm-tbaa"}
!8 = !{!9, !9, i64 0}
!9 = !{!"float", !10, i64 0}
!10 = !{!"0x192bc20", !7, i64 0}

avg 128 2016 21 21 1 2 VALID
Time cost of this operator: 0.0006293605
Lowered TIR:
@main = primfn(data_1: handle, tensor_1: handle) -> ()
  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
  buffers = {tensor: Buffer(tensor_2: Pointer(float32), float32, [128, 2016, 11, 11], []),
             data: Buffer(data_2: Pointer(float32), float32, [128, 2016, 21, 21], [])}
  buffer_map = {data_1: data, tensor_1: tensor} {
  attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 121968;
  allocate(tensor_3: Pointer(local float32), float32, [1]), storage_scope = local;
  attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 256 {
    tensor_3[0] = 0f32
    tensor_3[0] = ((float32*)tensor_3[0] + (float32*)data_2[(((floordiv(((blockIdx.x*256) + threadIdx.x), 121)*441) + (floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 121), 11)*42)) + (floormod(((blockIdx.x*256) + threadIdx.x), 11)*2))])
    tensor_2[((blockIdx.x*256) + threadIdx.x)] = (float32*)tensor_3[0]
  }
}


; ModuleID = 'TVMAMDGPUModule'
source_filename = "TVMAMDGPUModule"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa-hcc"

; Function Attrs: nofree nounwind
define dllexport amdgpu_kernel void @default_function_kernel0(float addrspace(1)* noalias nocapture readonly %0, float addrspace(1)* noalias nocapture %1) local_unnamed_addr #0 {
entry:
  %2 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %3 = tail call i32 @llvm.amdgcn.workitem.id.x()
  %4 = shl nsw i32 %2, 8
  %5 = add nsw i32 %4, %3
  %6 = srem i32 %5, 11
  %7 = shl nsw i32 %6, 1
  %8 = sdiv i32 %5, 121
  %9 = mul i32 %8, 121
  %.decomposed = sub i32 %5, %9
  %10 = sdiv i32 %.decomposed, 11
  %11 = mul nsw i32 %10, 42
  %12 = mul nsw i32 %8, 441
  %13 = add i32 %7, %12
  %14 = add i32 %13, %11
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds float, float addrspace(1)* %0, i64 %15
  %17 = load float, float addrspace(1)* %16, align 4, !tbaa !4
  %18 = fadd float %17, 0.000000e+00
  %19 = sext i32 %5 to i64
  %20 = getelementptr inbounds float, float addrspace(1)* %1, i64 %19
  store float %18, float addrspace(1)* %20, align 4, !tbaa !8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workgroup.id.x() #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nofree nounwind "amdgpu-flat-work-group-size"="1,1024" "no-nans-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 12.0.0 (/src/external/llvm-project/clang 1100ebe275a9dcc79a9abbda902b6f10738f2f5d)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"0x36040d0", !7, i64 0}
!7 = !{!"tvm-tbaa"}
!8 = !{!9, !9, i64 0}
!9 = !{!"float", !10, i64 0}
!10 = !{!"0x3602c60", !7, i64 0}

avg 128 42 165 165 3 2 SAME
Time cost of this operator: 0.0016386066
Lowered TIR:
@main = primfn(data_1: handle, tensor_1: handle) -> ()
  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
  buffers = {tensor: Buffer(tensor_2: Pointer(float32), float32, [128, 42, 83, 83], []),
             data: Buffer(data_2: Pointer(float32), float32, [128, 42, 165, 165], [])}
  buffer_map = {data_1: data, tensor_1: tensor} {
  attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 144669;
  allocate(tensor_3: Pointer(local float32), float32, [1]), storage_scope = local;
  attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 256 {
    tensor_3[0] = 0f32
    for (rv0: int32, 0, 3) {
      for (rv1: int32, 0, 3) {
        tensor_3[0] = ((float32*)tensor_3[0] + @tir.if_then_else(((((1 <= ((floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 6889), 83)*2) + rv0)) && (((floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 6889), 83)*2) + rv0) < 166)) && (1 <= ((floormod(((blockIdx.x*256) + threadIdx.x), 83)*2) + rv1))) && (((floormod(((blockIdx.x*256) + threadIdx.x), 83)*2) + rv1) < 166)), (float32*)data_2[((((((floordiv(((blockIdx.x*256) + threadIdx.x), 6889)*27225) + (floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 6889), 83)*330)) + (rv0*165)) + (floormod(((blockIdx.x*256) + threadIdx.x), 83)*2)) + rv1) - 166)], 0f32, dtype=float32))
      }
    }
    tensor_2[((blockIdx.x*256) + threadIdx.x)] = ((float32*)tensor_3[0]*0.111111f32)
  }
}


; ModuleID = 'TVMAMDGPUModule'
source_filename = "TVMAMDGPUModule"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa-hcc"

; Function Attrs: nofree nounwind
define dllexport amdgpu_kernel void @default_function_kernel0(float addrspace(1)* noalias nocapture readonly %0, float addrspace(1)* noalias nocapture %1) local_unnamed_addr #0 {
entry:
  %2 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %3 = tail call i32 @llvm.amdgcn.workitem.id.x()
  %4 = shl i32 %2, 8
  %5 = add nsw i32 %4, %3
  %6 = srem i32 %5, 83
  %7 = shl nsw i32 %6, 1
  %8 = sdiv i32 %5, 6889
  %9 = mul i32 %8, 6889
  %.decomposed = sub i32 %5, %9
  %10 = sdiv i32 %.decomposed, 83
  %11 = shl nsw i32 %10, 1
  %12 = add nsw i32 %11, -1
  %13 = mul nsw i32 %10, 330
  %14 = mul nsw i32 %8, 27225
  %15 = icmp ult i32 %12, 165
  %.off6 = add nsw i32 %7, -1
  %16 = icmp ult i32 %.off6, 165
  %17 = and i1 %15, %16
  br i1 %17, label %if_then, label %if_end

if_then:                                          ; preds = %entry
  %18 = add nuw nsw i32 %7, -166
  %19 = add i32 %18, %14
  %20 = add i32 %19, %13
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds float, float addrspace(1)* %0, i64 %21
  %23 = load float, float addrspace(1)* %22, align 4, !tbaa !4
  %phitmp = fadd float %23, 0.000000e+00
  br label %if_end

if_end:                                           ; preds = %entry, %if_then
  %24 = phi float [ %phitmp, %if_then ], [ 0.000000e+00, %entry ]
  %25 = icmp ult i32 %7, 165
  %26 = and i1 %15, %25
  br i1 %26, label %if_then.1, label %if_end.1

if_then.1:                                        ; preds = %if_end
  %27 = or i32 %7, 1
  %28 = add nsw i32 %27, -166
  %29 = add i32 %28, %14
  %30 = add i32 %29, %13
  %31 = sext i32 %30 to i64
  %32 = getelementptr inbounds float, float addrspace(1)* %0, i64 %31
  %33 = load float, float addrspace(1)* %32, align 4, !tbaa !4
  br label %if_end.1

if_end.1:                                         ; preds = %if_then.1, %if_end
  %34 = phi float [ %33, %if_then.1 ], [ 0.000000e+00, %if_end ]
  %35 = fadd float %24, %34
  %.off6.2 = or i32 %7, 1
  %36 = icmp ult i32 %.off6.2, 165
  %37 = and i1 %15, %36
  br i1 %37, label %if_then.2, label %if_end.2

if_then.2:                                        ; preds = %if_end.1
  %38 = add nsw i32 %7, -164
  %39 = add i32 %38, %14
  %40 = add i32 %39, %13
  %41 = sext i32 %40 to i64
  %42 = getelementptr inbounds float, float addrspace(1)* %0, i64 %41
  %43 = load float, float addrspace(1)* %42, align 4, !tbaa !4
  br label %if_end.2

if_end.2:                                         ; preds = %if_then.2, %if_end.1
  %44 = phi float [ %43, %if_then.2 ], [ 0.000000e+00, %if_end.1 ]
  %45 = fadd float %35, %44
  %46 = icmp ult i32 %11, 165
  %47 = and i1 %46, %16
  br i1 %47, label %if_then.19, label %if_end.110

if_then.19:                                       ; preds = %if_end.2
  %48 = add nuw nsw i32 %7, -166
  %49 = add i32 %48, %14
  %50 = add i32 %49, %13
  %51 = add i32 %50, 165
  %52 = sext i32 %51 to i64
  %53 = getelementptr inbounds float, float addrspace(1)* %0, i64 %52
  %54 = load float, float addrspace(1)* %53, align 4, !tbaa !4
  br label %if_end.110

if_end.110:                                       ; preds = %if_then.19, %if_end.2
  %55 = phi float [ %54, %if_then.19 ], [ 0.000000e+00, %if_end.2 ]
  %56 = fadd float %45, %55
  %57 = and i1 %46, %25
  br i1 %57, label %if_then.1.1, label %if_end.1.1

if_then.1.1:                                      ; preds = %if_end.110
  %58 = or i32 %7, 1
  %59 = add nsw i32 %58, -166
  %60 = add i32 %59, %14
  %61 = add i32 %60, %13
  %62 = add i32 %61, 165
  %63 = sext i32 %62 to i64
  %64 = getelementptr inbounds float, float addrspace(1)* %0, i64 %63
  %65 = load float, float addrspace(1)* %64, align 4, !tbaa !4
  br label %if_end.1.1

if_end.1.1:                                       ; preds = %if_then.1.1, %if_end.110
  %66 = phi float [ %65, %if_then.1.1 ], [ 0.000000e+00, %if_end.110 ]
  %67 = fadd float %56, %66
  %68 = and i1 %46, %36
  br i1 %68, label %if_then.2.1, label %if_end.2.1

if_then.2.1:                                      ; preds = %if_end.1.1
  %69 = add nsw i32 %7, -164
  %70 = add i32 %69, %14
  %71 = add i32 %70, %13
  %72 = add i32 %71, 165
  %73 = sext i32 %72 to i64
  %74 = getelementptr inbounds float, float addrspace(1)* %0, i64 %73
  %75 = load float, float addrspace(1)* %74, align 4, !tbaa !4
  br label %if_end.2.1

if_end.2.1:                                       ; preds = %if_then.2.1, %if_end.1.1
  %76 = phi float [ %75, %if_then.2.1 ], [ 0.000000e+00, %if_end.1.1 ]
  %77 = fadd float %67, %76
  %.off.2 = or i32 %11, 1
  %78 = icmp ult i32 %.off.2, 165
  %79 = and i1 %78, %16
  br i1 %79, label %if_then.212, label %if_end.213

if_then.212:                                      ; preds = %if_end.2.1
  %80 = add nuw nsw i32 %7, -166
  %81 = add i32 %80, %14
  %82 = add i32 %81, %13
  %83 = add i32 %82, 330
  %84 = sext i32 %83 to i64
  %85 = getelementptr inbounds float, float addrspace(1)* %0, i64 %84
  %86 = load float, float addrspace(1)* %85, align 4, !tbaa !4
  br label %if_end.213

if_end.213:                                       ; preds = %if_then.212, %if_end.2.1
  %87 = phi float [ %86, %if_then.212 ], [ 0.000000e+00, %if_end.2.1 ]
  %88 = fadd float %77, %87
  %89 = and i1 %78, %25
  br i1 %89, label %if_then.1.2, label %if_end.1.2

if_then.1.2:                                      ; preds = %if_end.213
  %90 = or i32 %7, 1
  %91 = add nsw i32 %90, -166
  %92 = add i32 %91, %14
  %93 = add i32 %92, %13
  %94 = add i32 %93, 330
  %95 = sext i32 %94 to i64
  %96 = getelementptr inbounds float, float addrspace(1)* %0, i64 %95
  %97 = load float, float addrspace(1)* %96, align 4, !tbaa !4
  br label %if_end.1.2

if_end.1.2:                                       ; preds = %if_then.1.2, %if_end.213
  %98 = phi float [ %97, %if_then.1.2 ], [ 0.000000e+00, %if_end.213 ]
  %99 = fadd float %88, %98
  %100 = and i1 %78, %36
  br i1 %100, label %if_then.2.2, label %if_end.2.2

if_then.2.2:                                      ; preds = %if_end.1.2
  %101 = add nsw i32 %7, -164
  %102 = add i32 %101, %14
  %103 = add i32 %102, %13
  %104 = add i32 %103, 330
  %105 = sext i32 %104 to i64
  %106 = getelementptr inbounds float, float addrspace(1)* %0, i64 %105
  %107 = load float, float addrspace(1)* %106, align 4, !tbaa !4
  br label %if_end.2.2

if_end.2.2:                                       ; preds = %if_then.2.2, %if_end.1.2
  %108 = phi float [ %107, %if_then.2.2 ], [ 0.000000e+00, %if_end.1.2 ]
  %109 = fadd float %99, %108
  %110 = fmul float %109, 0x3FBC71C720000000
  %111 = sext i32 %5 to i64
  %112 = getelementptr inbounds float, float addrspace(1)* %1, i64 %111
  store float %110, float addrspace(1)* %112, align 4, !tbaa !8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workgroup.id.x() #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nofree nounwind "amdgpu-flat-work-group-size"="1,1024" "no-nans-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 12.0.0 (/src/external/llvm-project/clang 1100ebe275a9dcc79a9abbda902b6f10738f2f5d)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"0x1ee6c90", !7, i64 0}
!7 = !{!"tvm-tbaa"}
!8 = !{!9, !9, i64 0}
!9 = !{!"float", !10, i64 0}
!10 = !{!"0x1ee6c50", !7, i64 0}

avg 128 84 42 42 3 1 SAME
Time cost of this operator: 0.0003274598
Lowered TIR:
@main = primfn(data_1: handle, tensor_1: handle) -> ()
  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
  buffers = {tensor: Buffer(tensor_2: Pointer(float32), float32, [128, 84, 42, 42], []),
             data: Buffer(data_2: Pointer(float32), float32, [128, 84, 42, 42], [])}
  buffer_map = {data_1: data, tensor_1: tensor} {
  attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 74088;
  allocate(tensor_3: Pointer(local float32), float32, [1]), storage_scope = local;
  attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 256 {
    tensor_3[0] = 0f32
    for (rv0: int32, 0, 3) {
      for (rv1: int32, 0, 3) {
        tensor_3[0] = ((float32*)tensor_3[0] + @tir.if_then_else(((((1 <= (floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 1764), 42) + rv0)) && ((floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 1764), 42) + rv0) < 43)) && (1 <= (rv1 + floormod(((blockIdx.x*256) + threadIdx.x), 42)))) && ((rv1 + floormod(((blockIdx.x*256) + threadIdx.x), 42)) < 43)), (float32*)data_2[(((((blockIdx.x*256) + (rv0*42)) + threadIdx.x) + rv1) - 43)], 0f32, dtype=float32))
      }
    }
    tensor_2[((blockIdx.x*256) + threadIdx.x)] = ((float32*)tensor_3[0]*0.111111f32)
  }
}


; ModuleID = 'TVMAMDGPUModule'
source_filename = "TVMAMDGPUModule"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa-hcc"

; Function Attrs: nofree nounwind
define dllexport amdgpu_kernel void @default_function_kernel0(float addrspace(1)* noalias nocapture readonly %0, float addrspace(1)* noalias nocapture %1) local_unnamed_addr #0 {
entry:
  %2 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %3 = tail call i32 @llvm.amdgcn.workitem.id.x()
  %4 = shl i32 %2, 8
  %5 = add i32 %4, %3
  %6 = srem i32 %5, 42
  %7 = srem i32 %5, 1764
  %8 = sdiv i32 %7, 42
  %9 = add nsw i32 %8, -1
  %10 = add nsw i32 %6, -1
  %11 = icmp ult i32 %9, 42
  %12 = icmp ult i32 %10, 42
  %13 = and i1 %11, %12
  br i1 %13, label %if_then, label %if_end

if_then:                                          ; preds = %entry
  %14 = add i32 %5, -43
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds float, float addrspace(1)* %0, i64 %15
  %17 = load float, float addrspace(1)* %16, align 4, !tbaa !4
  %phitmp = fadd float %17, 0.000000e+00
  br label %if_end

if_end:                                           ; preds = %entry, %if_then
  %18 = phi float [ %phitmp, %if_then ], [ 0.000000e+00, %entry ]
  %19 = icmp ult i32 %6, 42
  %20 = and i1 %11, %19
  br i1 %20, label %if_then.1, label %if_end.1

if_then.1:                                        ; preds = %if_end
  %21 = add i32 %5, -42
  %22 = sext i32 %21 to i64
  %23 = getelementptr inbounds float, float addrspace(1)* %0, i64 %22
  %24 = load float, float addrspace(1)* %23, align 4, !tbaa !4
  br label %if_end.1

if_end.1:                                         ; preds = %if_then.1, %if_end
  %25 = phi float [ %24, %if_then.1 ], [ 0.000000e+00, %if_end ]
  %26 = fadd float %18, %25
  %.off6.2 = add nsw i32 %6, 1
  %27 = icmp ult i32 %.off6.2, 42
  %28 = and i1 %11, %27
  br i1 %28, label %if_then.2, label %if_end.2

if_then.2:                                        ; preds = %if_end.1
  %29 = add i32 %5, -41
  %30 = sext i32 %29 to i64
  %31 = getelementptr inbounds float, float addrspace(1)* %0, i64 %30
  %32 = load float, float addrspace(1)* %31, align 4, !tbaa !4
  br label %if_end.2

if_end.2:                                         ; preds = %if_then.2, %if_end.1
  %33 = phi float [ %32, %if_then.2 ], [ 0.000000e+00, %if_end.1 ]
  %34 = fadd float %26, %33
  %35 = icmp ult i32 %8, 42
  %36 = and i1 %35, %12
  br i1 %36, label %if_then.19, label %if_end.110

if_then.19:                                       ; preds = %if_end.2
  %37 = add i32 %5, -1
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds float, float addrspace(1)* %0, i64 %38
  %40 = load float, float addrspace(1)* %39, align 4, !tbaa !4
  br label %if_end.110

if_end.110:                                       ; preds = %if_then.19, %if_end.2
  %41 = phi float [ %40, %if_then.19 ], [ 0.000000e+00, %if_end.2 ]
  %42 = fadd float %34, %41
  %43 = and i1 %35, %19
  br i1 %43, label %if_then.1.1, label %if_end.1.1

if_then.1.1:                                      ; preds = %if_end.110
  %44 = sext i32 %5 to i64
  %45 = getelementptr inbounds float, float addrspace(1)* %0, i64 %44
  %46 = load float, float addrspace(1)* %45, align 4, !tbaa !4
  br label %if_end.1.1

if_end.1.1:                                       ; preds = %if_then.1.1, %if_end.110
  %47 = phi float [ %46, %if_then.1.1 ], [ 0.000000e+00, %if_end.110 ]
  %48 = fadd float %42, %47
  %49 = and i1 %35, %27
  br i1 %49, label %if_then.2.1, label %if_end.2.1

if_then.2.1:                                      ; preds = %if_end.1.1
  %50 = add i32 %5, 1
  %51 = sext i32 %50 to i64
  %52 = getelementptr inbounds float, float addrspace(1)* %0, i64 %51
  %53 = load float, float addrspace(1)* %52, align 4, !tbaa !4
  br label %if_end.2.1

if_end.2.1:                                       ; preds = %if_then.2.1, %if_end.1.1
  %54 = phi float [ %53, %if_then.2.1 ], [ 0.000000e+00, %if_end.1.1 ]
  %55 = fadd float %48, %54
  %.off.2 = add nsw i32 %8, 1
  %56 = icmp ult i32 %.off.2, 42
  %57 = and i1 %56, %12
  br i1 %57, label %if_then.211, label %if_end.212

if_then.211:                                      ; preds = %if_end.2.1
  %58 = add i32 %5, 41
  %59 = sext i32 %58 to i64
  %60 = getelementptr inbounds float, float addrspace(1)* %0, i64 %59
  %61 = load float, float addrspace(1)* %60, align 4, !tbaa !4
  br label %if_end.212

if_end.212:                                       ; preds = %if_then.211, %if_end.2.1
  %62 = phi float [ %61, %if_then.211 ], [ 0.000000e+00, %if_end.2.1 ]
  %63 = fadd float %55, %62
  %64 = and i1 %56, %19
  br i1 %64, label %if_then.1.2, label %if_end.1.2

if_then.1.2:                                      ; preds = %if_end.212
  %65 = add i32 %5, 42
  %66 = sext i32 %65 to i64
  %67 = getelementptr inbounds float, float addrspace(1)* %0, i64 %66
  %68 = load float, float addrspace(1)* %67, align 4, !tbaa !4
  br label %if_end.1.2

if_end.1.2:                                       ; preds = %if_then.1.2, %if_end.212
  %69 = phi float [ %68, %if_then.1.2 ], [ 0.000000e+00, %if_end.212 ]
  %70 = fadd float %63, %69
  %71 = and i1 %56, %27
  br i1 %71, label %if_then.2.2, label %if_end.2.2

if_then.2.2:                                      ; preds = %if_end.1.2
  %72 = add i32 %5, 43
  %73 = sext i32 %72 to i64
  %74 = getelementptr inbounds float, float addrspace(1)* %0, i64 %73
  %75 = load float, float addrspace(1)* %74, align 4, !tbaa !4
  br label %if_end.2.2

if_end.2.2:                                       ; preds = %if_then.2.2, %if_end.1.2
  %76 = phi float [ %75, %if_then.2.2 ], [ 0.000000e+00, %if_end.1.2 ]
  %77 = fadd float %70, %76
  %78 = fmul float %77, 0x3FBC71C720000000
  %79 = sext i32 %5 to i64
  %80 = getelementptr inbounds float, float addrspace(1)* %1, i64 %79
  store float %78, float addrspace(1)* %80, align 4, !tbaa !8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workgroup.id.x() #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nofree nounwind "amdgpu-flat-work-group-size"="1,1024" "no-nans-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 12.0.0 (/src/external/llvm-project/clang 1100ebe275a9dcc79a9abbda902b6f10738f2f5d)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"0x32bd8d0", !7, i64 0}
!7 = !{!"tvm-tbaa"}
!8 = !{!9, !9, i64 0}
!9 = !{!"float", !10, i64 0}
!10 = !{!"0x32bd890", !7, i64 0}

avg 128 336 21 21 3 1 SAME
Time cost of this operator: 0.0003302989
Lowered TIR:
@main = primfn(data_1: handle, tensor_1: handle) -> ()
  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
  buffers = {tensor: Buffer(tensor_2: Pointer(float32), float32, [128, 336, 21, 21], []),
             data: Buffer(data_2: Pointer(float32), float32, [128, 336, 21, 21], [])}
  buffer_map = {data_1: data, tensor_1: tensor} {
  attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 74088;
  allocate(tensor_3: Pointer(local float32), float32, [1]), storage_scope = local;
  attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 256 {
    tensor_3[0] = 0f32
    for (rv0: int32, 0, 3) {
      for (rv1: int32, 0, 3) {
        tensor_3[0] = ((float32*)tensor_3[0] + @tir.if_then_else(((((1 <= (floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 441), 21) + rv0)) && ((floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 441), 21) + rv0) < 22)) && (1 <= (rv1 + floormod(((blockIdx.x*256) + threadIdx.x), 21)))) && ((rv1 + floormod(((blockIdx.x*256) + threadIdx.x), 21)) < 22)), (float32*)data_2[(((((blockIdx.x*256) + (rv0*21)) + threadIdx.x) + rv1) - 22)], 0f32, dtype=float32))
      }
    }
    tensor_2[((blockIdx.x*256) + threadIdx.x)] = ((float32*)tensor_3[0]*0.111111f32)
  }
}


; ModuleID = 'TVMAMDGPUModule'
source_filename = "TVMAMDGPUModule"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa-hcc"

; Function Attrs: nofree nounwind
define dllexport amdgpu_kernel void @default_function_kernel0(float addrspace(1)* noalias nocapture readonly %0, float addrspace(1)* noalias nocapture %1) local_unnamed_addr #0 {
entry:
  %2 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %3 = tail call i32 @llvm.amdgcn.workitem.id.x()
  %4 = shl i32 %2, 8
  %5 = add i32 %4, %3
  %6 = srem i32 %5, 21
  %7 = srem i32 %5, 441
  %8 = sdiv i32 %7, 21
  %9 = add nsw i32 %8, -1
  %10 = add nsw i32 %6, -1
  %11 = icmp ult i32 %9, 21
  %12 = icmp ult i32 %10, 21
  %13 = and i1 %11, %12
  br i1 %13, label %if_then, label %if_end

if_then:                                          ; preds = %entry
  %14 = add i32 %5, -22
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds float, float addrspace(1)* %0, i64 %15
  %17 = load float, float addrspace(1)* %16, align 4, !tbaa !4
  %phitmp = fadd float %17, 0.000000e+00
  br label %if_end

if_end:                                           ; preds = %entry, %if_then
  %18 = phi float [ %phitmp, %if_then ], [ 0.000000e+00, %entry ]
  %19 = icmp ult i32 %6, 21
  %20 = and i1 %11, %19
  br i1 %20, label %if_then.1, label %if_end.1

if_then.1:                                        ; preds = %if_end
  %21 = add i32 %5, -21
  %22 = sext i32 %21 to i64
  %23 = getelementptr inbounds float, float addrspace(1)* %0, i64 %22
  %24 = load float, float addrspace(1)* %23, align 4, !tbaa !4
  br label %if_end.1

if_end.1:                                         ; preds = %if_then.1, %if_end
  %25 = phi float [ %24, %if_then.1 ], [ 0.000000e+00, %if_end ]
  %26 = fadd float %18, %25
  %.off6.2 = add nsw i32 %6, 1
  %27 = icmp ult i32 %.off6.2, 21
  %28 = and i1 %11, %27
  br i1 %28, label %if_then.2, label %if_end.2

if_then.2:                                        ; preds = %if_end.1
  %29 = add i32 %5, -20
  %30 = sext i32 %29 to i64
  %31 = getelementptr inbounds float, float addrspace(1)* %0, i64 %30
  %32 = load float, float addrspace(1)* %31, align 4, !tbaa !4
  br label %if_end.2

if_end.2:                                         ; preds = %if_then.2, %if_end.1
  %33 = phi float [ %32, %if_then.2 ], [ 0.000000e+00, %if_end.1 ]
  %34 = fadd float %26, %33
  %35 = icmp ult i32 %8, 21
  %36 = and i1 %35, %12
  br i1 %36, label %if_then.19, label %if_end.110

if_then.19:                                       ; preds = %if_end.2
  %37 = add i32 %5, -1
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds float, float addrspace(1)* %0, i64 %38
  %40 = load float, float addrspace(1)* %39, align 4, !tbaa !4
  br label %if_end.110

if_end.110:                                       ; preds = %if_then.19, %if_end.2
  %41 = phi float [ %40, %if_then.19 ], [ 0.000000e+00, %if_end.2 ]
  %42 = fadd float %34, %41
  %43 = and i1 %35, %19
  br i1 %43, label %if_then.1.1, label %if_end.1.1

if_then.1.1:                                      ; preds = %if_end.110
  %44 = sext i32 %5 to i64
  %45 = getelementptr inbounds float, float addrspace(1)* %0, i64 %44
  %46 = load float, float addrspace(1)* %45, align 4, !tbaa !4
  br label %if_end.1.1

if_end.1.1:                                       ; preds = %if_then.1.1, %if_end.110
  %47 = phi float [ %46, %if_then.1.1 ], [ 0.000000e+00, %if_end.110 ]
  %48 = fadd float %42, %47
  %49 = and i1 %35, %27
  br i1 %49, label %if_then.2.1, label %if_end.2.1

if_then.2.1:                                      ; preds = %if_end.1.1
  %50 = add i32 %5, 1
  %51 = sext i32 %50 to i64
  %52 = getelementptr inbounds float, float addrspace(1)* %0, i64 %51
  %53 = load float, float addrspace(1)* %52, align 4, !tbaa !4
  br label %if_end.2.1

if_end.2.1:                                       ; preds = %if_then.2.1, %if_end.1.1
  %54 = phi float [ %53, %if_then.2.1 ], [ 0.000000e+00, %if_end.1.1 ]
  %55 = fadd float %48, %54
  %.off.2 = add nsw i32 %8, 1
  %56 = icmp ult i32 %.off.2, 21
  %57 = and i1 %56, %12
  br i1 %57, label %if_then.211, label %if_end.212

if_then.211:                                      ; preds = %if_end.2.1
  %58 = add i32 %5, 20
  %59 = sext i32 %58 to i64
  %60 = getelementptr inbounds float, float addrspace(1)* %0, i64 %59
  %61 = load float, float addrspace(1)* %60, align 4, !tbaa !4
  br label %if_end.212

if_end.212:                                       ; preds = %if_then.211, %if_end.2.1
  %62 = phi float [ %61, %if_then.211 ], [ 0.000000e+00, %if_end.2.1 ]
  %63 = fadd float %55, %62
  %64 = and i1 %56, %19
  br i1 %64, label %if_then.1.2, label %if_end.1.2

if_then.1.2:                                      ; preds = %if_end.212
  %65 = add i32 %5, 21
  %66 = sext i32 %65 to i64
  %67 = getelementptr inbounds float, float addrspace(1)* %0, i64 %66
  %68 = load float, float addrspace(1)* %67, align 4, !tbaa !4
  br label %if_end.1.2

if_end.1.2:                                       ; preds = %if_then.1.2, %if_end.212
  %69 = phi float [ %68, %if_then.1.2 ], [ 0.000000e+00, %if_end.212 ]
  %70 = fadd float %63, %69
  %71 = and i1 %56, %27
  br i1 %71, label %if_then.2.2, label %if_end.2.2

if_then.2.2:                                      ; preds = %if_end.1.2
  %72 = add i32 %5, 22
  %73 = sext i32 %72 to i64
  %74 = getelementptr inbounds float, float addrspace(1)* %0, i64 %73
  %75 = load float, float addrspace(1)* %74, align 4, !tbaa !4
  br label %if_end.2.2

if_end.2.2:                                       ; preds = %if_then.2.2, %if_end.1.2
  %76 = phi float [ %75, %if_then.2.2 ], [ 0.000000e+00, %if_end.1.2 ]
  %77 = fadd float %70, %76
  %78 = fmul float %77, 0x3FBC71C720000000
  %79 = sext i32 %5 to i64
  %80 = getelementptr inbounds float, float addrspace(1)* %1, i64 %79
  store float %78, float addrspace(1)* %80, align 4, !tbaa !8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workgroup.id.x() #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nofree nounwind "amdgpu-flat-work-group-size"="1,1024" "no-nans-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 12.0.0 (/src/external/llvm-project/clang 1100ebe275a9dcc79a9abbda902b6f10738f2f5d)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"0x2713980", !7, i64 0}
!7 = !{!"tvm-tbaa"}
!8 = !{!9, !9, i64 0}
!9 = !{!"float", !10, i64 0}
!10 = !{!"0x2712ce0", !7, i64 0}

avg 128 168 42 42 3 1 SAME
Time cost of this operator: 0.0006580220
Lowered TIR:
@main = primfn(data_1: handle, tensor_1: handle) -> ()
  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}
  buffers = {tensor: Buffer(tensor_2: Pointer(float32), float32, [128, 168, 42, 42], []),
             data: Buffer(data_2: Pointer(float32), float32, [128, 168, 42, 42], [])}
  buffer_map = {data_1: data, tensor_1: tensor} {
  attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 148176;
  allocate(tensor_3: Pointer(local float32), float32, [1]), storage_scope = local;
  attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 256 {
    tensor_3[0] = 0f32
    for (rv0: int32, 0, 3) {
      for (rv1: int32, 0, 3) {
        tensor_3[0] = ((float32*)tensor_3[0] + @tir.if_then_else(((((1 <= (floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 1764), 42) + rv0)) && ((floordiv(floormod(((blockIdx.x*256) + threadIdx.x), 1764), 42) + rv0) < 43)) && (1 <= (rv1 + floormod(((blockIdx.x*256) + threadIdx.x), 42)))) && ((rv1 + floormod(((blockIdx.x*256) + threadIdx.x), 42)) < 43)), (float32*)data_2[(((((blockIdx.x*256) + (rv0*42)) + threadIdx.x) + rv1) - 43)], 0f32, dtype=float32))
      }
    }
    tensor_2[((blockIdx.x*256) + threadIdx.x)] = ((float32*)tensor_3[0]*0.111111f32)
  }
}


; ModuleID = 'TVMAMDGPUModule'
source_filename = "TVMAMDGPUModule"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa-hcc"

; Function Attrs: nofree nounwind
define dllexport amdgpu_kernel void @default_function_kernel0(float addrspace(1)* noalias nocapture readonly %0, float addrspace(1)* noalias nocapture %1) local_unnamed_addr #0 {
entry:
  %2 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %3 = tail call i32 @llvm.amdgcn.workitem.id.x()
  %4 = shl i32 %2, 8
  %5 = add i32 %4, %3
  %6 = srem i32 %5, 42
  %7 = srem i32 %5, 1764
  %8 = sdiv i32 %7, 42
  %9 = add nsw i32 %8, -1
  %10 = add nsw i32 %6, -1
  %11 = icmp ult i32 %9, 42
  %12 = icmp ult i32 %10, 42
  %13 = and i1 %11, %12
  br i1 %13, label %if_then, label %if_end

if_then:                                          ; preds = %entry
  %14 = add i32 %5, -43
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds float, float addrspace(1)* %0, i64 %15
  %17 = load float, float addrspace(1)* %16, align 4, !tbaa !4
  %phitmp = fadd float %17, 0.000000e+00
  br label %if_end

if_end:                                           ; preds = %entry, %if_then
  %18 = phi float [ %phitmp, %if_then ], [ 0.000000e+00, %entry ]
  %19 = icmp ult i32 %6, 42
  %20 = and i1 %11, %19
  br i1 %20, label %if_then.1, label %if_end.1

if_then.1:                                        ; preds = %if_end
  %21 = add i32 %5, -42
  %22 = sext i32 %21 to i64
  %23 = getelementptr inbounds float, float addrspace(1)* %0, i64 %22
  %24 = load float, float addrspace(1)* %23, align 4, !tbaa !4
  br label %if_end.1

if_end.1:                                         ; preds = %if_then.1, %if_end
  %25 = phi float [ %24, %if_then.1 ], [ 0.000000e+00, %if_end ]
  %26 = fadd float %18, %25
  %.off6.2 = add nsw i32 %6, 1
  %27 = icmp ult i32 %.off6.2, 42
  %28 = and i1 %11, %27
  br i1 %28, label %if_then.2, label %if_end.2

if_then.2:                                        ; preds = %if_end.1
  %29 = add i32 %5, -41
  %30 = sext i32 %29 to i64
  %31 = getelementptr inbounds float, float addrspace(1)* %0, i64 %30
  %32 = load float, float addrspace(1)* %31, align 4, !tbaa !4
  br label %if_end.2

if_end.2:                                         ; preds = %if_then.2, %if_end.1
  %33 = phi float [ %32, %if_then.2 ], [ 0.000000e+00, %if_end.1 ]
  %34 = fadd float %26, %33
  %35 = icmp ult i32 %8, 42
  %36 = and i1 %35, %12
  br i1 %36, label %if_then.19, label %if_end.110

if_then.19:                                       ; preds = %if_end.2
  %37 = add i32 %5, -1
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds float, float addrspace(1)* %0, i64 %38
  %40 = load float, float addrspace(1)* %39, align 4, !tbaa !4
  br label %if_end.110

if_end.110:                                       ; preds = %if_then.19, %if_end.2
  %41 = phi float [ %40, %if_then.19 ], [ 0.000000e+00, %if_end.2 ]
  %42 = fadd float %34, %41
  %43 = and i1 %35, %19
  br i1 %43, label %if_then.1.1, label %if_end.1.1

if_then.1.1:                                      ; preds = %if_end.110
  %44 = sext i32 %5 to i64
  %45 = getelementptr inbounds float, float addrspace(1)* %0, i64 %44
  %46 = load float, float addrspace(1)* %45, align 4, !tbaa !4
  br label %if_end.1.1

if_end.1.1:                                       ; preds = %if_then.1.1, %if_end.110
  %47 = phi float [ %46, %if_then.1.1 ], [ 0.000000e+00, %if_end.110 ]
  %48 = fadd float %42, %47
  %49 = and i1 %35, %27
  br i1 %49, label %if_then.2.1, label %if_end.2.1

if_then.2.1:                                      ; preds = %if_end.1.1
  %50 = add i32 %5, 1
  %51 = sext i32 %50 to i64
  %52 = getelementptr inbounds float, float addrspace(1)* %0, i64 %51
  %53 = load float, float addrspace(1)* %52, align 4, !tbaa !4
  br label %if_end.2.1

if_end.2.1:                                       ; preds = %if_then.2.1, %if_end.1.1
  %54 = phi float [ %53, %if_then.2.1 ], [ 0.000000e+00, %if_end.1.1 ]
  %55 = fadd float %48, %54
  %.off.2 = add nsw i32 %8, 1
  %56 = icmp ult i32 %.off.2, 42
  %57 = and i1 %56, %12
  br i1 %57, label %if_then.211, label %if_end.212

if_then.211:                                      ; preds = %if_end.2.1
  %58 = add i32 %5, 41
  %59 = sext i32 %58 to i64
  %60 = getelementptr inbounds float, float addrspace(1)* %0, i64 %59
  %61 = load float, float addrspace(1)* %60, align 4, !tbaa !4
  br label %if_end.212

if_end.212:                                       ; preds = %if_then.211, %if_end.2.1
  %62 = phi float [ %61, %if_then.211 ], [ 0.000000e+00, %if_end.2.1 ]
  %63 = fadd float %55, %62
  %64 = and i1 %56, %19
  br i1 %64, label %if_then.1.2, label %if_end.1.2

if_then.1.2:                                      ; preds = %if_end.212
  %65 = add i32 %5, 42
  %66 = sext i32 %65 to i64
  %67 = getelementptr inbounds float, float addrspace(1)* %0, i64 %66
  %68 = load float, float addrspace(1)* %67, align 4, !tbaa !4
  br label %if_end.1.2

if_end.1.2:                                       ; preds = %if_then.1.2, %if_end.212
  %69 = phi float [ %68, %if_then.1.2 ], [ 0.000000e+00, %if_end.212 ]
  %70 = fadd float %63, %69
  %71 = and i1 %56, %27
  br i1 %71, label %if_then.2.2, label %if_end.2.2

if_then.2.2:                                      ; preds = %if_end.1.2
  %72 = add i32 %5, 43
  %73 = sext i32 %72 to i64
  %74 = getelementptr inbounds float, float addrspace(1)* %0, i64 %73
  %75 = load float, float addrspace(1)* %74, align 4, !tbaa !4
  br label %if_end.2.2

if_end.2.2:                                       ; preds = %if_then.2.2, %if_end.1.2
  %76 = phi float [ %75, %if_then.2.2 ], [ 0.000000e+00, %if_end.1.2 ]
  %77 = fadd float %70, %76
  %78 = fmul float %77, 0x3FBC71C720000000
  %79 = sext i32 %5 to i64
  %80 = getelementptr inbounds float, float addrspace(1)* %1, i64 %79
  store float %78, float addrspace(1)* %80, align 4, !tbaa !8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workgroup.id.x() #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nofree nounwind "amdgpu-flat-work-group-size"="1,1024" "no-nans-fp-math"="true" }
attributes #1 = { nounwind readnone speculatable }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 12.0.0 (/src/external/llvm-project/clang 1100ebe275a9dcc79a9abbda902b6f10738f2f5d)"}
!4 = !{!5, !5, i64 0}
!5 = !{!"float", !6, i64 0}
!6 = !{!"0x20508b0", !7, i64 0}
!7 = !{!"tvm-tbaa"}
!8 = !{!9, !9, i64 0}
!9 = !{!"float", !10, i64 0}
!10 = !{!"0x2050870", !7, i64 0}

